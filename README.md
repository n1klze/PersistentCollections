# Неизменяемые структуры данных (Persistent Data Structures)

## 1. Выбранная тема, усложнения, состав команды

**Тема:** Персистентные структуры данных (Persistent Data Structures)

**Выбранные усложнения:**
- Обеспечить произвольную вложенность данных (по аналогии с динамическими языками), не отказываясь при этом полностью от типизации посредством generic/template.
- Реализовать универсальный undo-redo механизм для перечисленных структур с поддержкой каскадности (для вложенных структур).
- Реализовать более эффективное по скорости доступа представление структур данных, чем fat-node.

**Состав команды:**
- **Мельников Никита Сергеевич**, гр. 25221
- **Силицкий Андрей Сергеевич**, гр. 25221

---

## 2. Зоны ответственности
|Участник        | Зона ответственности                           |
|----------------|------------------------------------------------|      
|Мельников Никита|Реализация персистентного массива               |
|                |Покрытие тестами, настройка автодокументирования|
|                |undo-redo механизм                              |
|Андрей Силицкий |Реализация персистентного ассоциативного массива|
|                |Реализация персистентного связного списка       |

---

## 3. Краткое теористическое описание задачи и решения

### Краткое теоритическое описание задачи
Персистентные структуры данных — это структуры, которые при изменении не перезаписывают себя, а создают новую версию, сохраняя при этом доступ ко всем предыдущим состояниям.

Цель работы — реализация библиотеки персистентных структур данных (массив, двусвязный список, ассоциативный массив)

### Теоритическое описание решения 

**Для массива** выбран алгоритм `path copying` на базе 32-арного дерева (RRB-Tree):
- Любая модификация (например, изменение элемента) приводит к копированию только пути до листа в дереве (O(log₃₂ n)), все остальные части делятся между версиями.
- Это обеспечивает гораздо лучшую эффективность по памяти и времени, чем fat-node (где каждая ячейка хранит историю всех своих изменений).
- 32-арная структура уменьшает глубину дерева и улучшает производительность по сравнению с бинарными аналогами, поддерживая тем временем хорошую кэш-локальность.

**Для ассоциативного массива (мапы)** реализуется path copying на базе Hash Array Mapped Trie (HAMT):
- Такой подход обеспечивает аммортизационную сложность O(1) базовых операций и экономит память по сравнению с fat-node благодаря разделению ссылок на неизменняемые поддеревья.
- Path copying легко интегрируется с persistent-undo/redo.

**Для двусвязного списка** реализуется path copying:
- При любой модификации копируются только необходимые узлы и их связи, остальные участки списка делятся между версиями.

### Почему выбраны именно эти подходы

- Эффективностью по памяти и скорости по сравнению с fat-node (где всегда хранят всю историю в каждом элементе/узле).
- Универсальностью (поддержка вложенных immutable-структур и каскадных undo/redo).
- Такие структуры имеют широкое применение в реализации коллекций функциональных ЯП (например: [Clojure](https://clojure.org/reference/data_structures), [Scala Collections](https://www.scala-lang.org/api/current/scala/collection/immutable/Vector.html)).

---
